Attribute validation error for CFSPREADSHEET.
The value of the ACTION attribute, which is currently info, must be one of the values: READ,UPDATE,WRITE.
 
The error occurred in D:/inetpub/wwwroot/pmsd/sats/Timetracking/cfm/index.cfm: line 157
155 :         
156 :         <!--- FIXED: Get sheet info first, then find the data sheet --->
157 :         <cfspreadsheet action="info" src="#filePath#" name="sheetInfo">
158 :         
159 :         <!--- Log available sheets --->





<cfscript>
/* ====== CONFIG - change these ====== */
dsn        = "BRANCH_Directory";                // your CF datasource pointing to SQL Server
inFile     = expandPath("LPRAB Timekeeping Q2 2025 2026-noCol.xlsx");            // path to original Excel file (replace)
outFile    = expandPath("output_with_directorate.xlsx"); // path for new file
sheetName  = "Data";                                // sheet name with your main data
/* ================================== */

/* 1) Load mapping from DB: fullName -> DirectorateNameE */
getMapQuery = "
    SELECT DISTINCT fullName, DirectorateNameE
    FROM BRANCH_Directory.dbo.vUserInfo
    WHERE DirectorateNameE IS NOT NULL
";
mapQ = queryExecute(getMapQuery, [], {datasource = dsn});

/* Build a CF struct for fast lookup (keyed by trimmed fullName) */
map = {};
if (isQuery(mapQ) && mapQ.recordCount > 0) {
    for (i = 1; i <= mapQ.recordCount; i++) {
        key = trim(mapQ.fullName[i]);
        if (len(key)) {
            map[key] = mapQ.DirectorateNameE[i];
        }
    }
}

/* 2) Read the input spreadsheet into a query (headerrow=1 uses first row as column names) */
/* --- Safe spreadsheet read with fallbacks --- */
if (NOT fileExists(inFile)) {
    writeOutput("Error: input file not found: " & inFile);
    abort;
}

try {
    // try reading by sheet name using 'sheetname' attribute (many CF versions support this)
    cfspreadsheet(action="read", src=inFile, query="dataQ", headerrow=1, sheetname=sheetName);
} catch (any e1) {
    // If that failed, try reading by sheet index (1 = first sheet).
    // This handles CF builds that require numeric sheet ids.
    try {
        cfspreadsheet(action="read", src=inFile, query="dataQ", headerrow=1, sheet=1);
    } catch (any e2) {
        // Final fallback: try reading without specifying sheet (reads first sheet on many installs)
        try {
            cfspreadsheet(action="read", src=inFile, query="dataQ", headerrow=1);
        } catch (any e3) {
            // Give the admin a clear error message and the original exceptions for debugging
            writeOutput("Failed to read spreadsheet. Tried sheetname(""" & sheetName & """), sheet(1), and default. Errors below:" & "<br><br>");
            writeOutput("<b>Attempt 1 (sheetname):</b><br>" & xmlFormat(e1.message) & "<br><br>");
            writeOutput("<b>Attempt 2 (sheet=1):</b><br>" & xmlFormat(e2.message) & "<br><br>");
            writeOutput("<b>Attempt 3 (no sheet):</b><br>" & xmlFormat(e3.message) & "<br><br>");
            abort;
        }
    }
}

/* quick sanity check */
if (NOT isQuery(dataQ)) {
    writeOutput("Read operation returned no query. Please check sheet name '" & sheetName & "' and the file.");
    abort;
}


/* NOTE: cfspreadsheet converts header names' spaces to underscores.
   So "Contact Name" -> Contact_Name. We'll detect the actual column name. */
columns = listToArray(dataQ.columnList, ",");
contactCol = "";
for (i = 1; i <= arrayLen(columns); i++) {
    if (CompareNoCase(columns[i], "Contact_Name") == 0 or CompareNoCase(columns[i], "Contact Name") == 0) {
        contactCol = columns[i];
        break;
    }
}
if (contactCol == "") {
    /* fallback: try to find a column that includes the word "contact" */
    for (i = 1; i <= arrayLen(columns); i++) {
        if (FindNoCase("contact", columns[i])) {
            contactCol = columns[i];
            break;
        }
    }
}
if (contactCol == "") {
    writeOutput("Error: Could not find a Contact Name column. Column names found: " & dataQ.columnList);
    abort;
}

/* 3) Add a new column "Directorate" filled with empty strings (one per row) */
/* QueryAddColumn requires the 3rd argument to be an array of values (one per row). */
blankArr = arrayNew(1);
if (dataQ.recordCount > 0) {
    for (i = 1; i <= dataQ.recordCount; i++) {
        arrayAppend(blankArr, "");
    }
}
/* If recordCount = 0, blankArr is an empty array which is acceptable */
QueryAddColumn(dataQ, "Directorate", blankArr);

/* helper function: returns an array of parsed fullnames from a contact cell
   handles multiple lines (CR/LF), and "Last, First [..]" format conversion */
function parseContactCell(contactCell) {
    var arr = [];
    if (!len(trim(contactCell))) {
        return arr;
    }
    // split by CR or LF -> normalize to LF then split
    var normalized = reReplace(contactCell, "[\r\n]+", chr(10), "all");
    var lines = listToArray(normalized, chr(10));
    for (var j = 1; j <= arrayLen(lines); j++) {
        var line = trim(lines[j]);
        if (!len(line)) continue;
        // drop anything from the first '[' (e.g. "Last, First [Client Contact - Primary Client]")
        var pos = find("[", line);
        if (pos) {
            line = left(line, pos-1);
        }
        line = trim(line);
        // if "Last, First" -> convert to "First Last"
        if (find(",", line)) {
            var parts = listToArray(line, ",");
            if (arrayLen(parts) >= 2) {
                var first = trim(parts[2]);
                var last  = trim(parts[1]);
                fullname = first & (len(first) ? " " : "") & last;
            } else {
                fullname = trim(line);
            }
        } else {
            fullname = trim(line);
        }
        if (len(fullname)) {
            arrayAppend(arr, fullname);
        }
    }
    return arr;
}

/* 4) Process each row: parse contact(s), lookup map, combine unique directorates */
/* We'll write into the Directorate column using QuerySetCell */
for (r = 1; r <= dataQ.recordCount; r++) {
    contactVal = dataQ[contactCol][r];
    namesArr = parseContactCell(contactVal);
    /* collect directorates in a struct for dedupe */
    dset = {};
    if (arrayLen(namesArr) > 0) {
        for (k = 1; k <= arrayLen(namesArr); k++) {
            nm = namesArr[k];
            if (structKeyExists(map, nm)) {
                dset[ map[nm] ] = true;
            } else {
                /* fallback: try case-insensitive search inside mapQ (slow but covers casing mismatches) */
                if (isQuery(mapQ) && mapQ.recordCount > 0) {
                    for (mi = 1; mi <= mapQ.recordCount; mi++) {
                        if (CompareNoCase(mapQ.fullName[mi], nm) == 0) {
                            dset[ mapQ.DirectorateNameE[mi] ] = true;
                            break;
                        }
                    }
                }
            }
        }
    }
    /* build result string */
    dlist = [];
    for (dk in dset) {
        arrayAppend(dlist, dk);
    }
    if (arrayLen(dlist)) {
        result = arrayToList(dlist, ", ");
    } else {
        result = "Not found";
    }
    QuerySetCell(dataQ, "Directorate", result, r);
}

/* -------------------------
   Build output query with Directorate column immediately to the right of Contact column
   ------------------------- */

/* Get the original column names as an array */
origCols = listToArray(dataQ.columnList, ",");

/* find the actual Contact column name (we detected it earlier into contactCol) */
/* If contactCol not set for some reason, try to find a column containing 'contact' */
if (NOT structKeyExists(variables, "contactCol") OR len(trim(contactCol)) EQ 0) {
    for (i = 1; i <= arrayLen(origCols); i++) {
        if (FindNoCase("contact", origCols[i])) {
            contactCol = origCols[i];
            break;
        }
    }
}

/* Build the desired column order: insert "Directorate" right after contactCol */
desiredCols = [];
inserted = false;
for (i = 1; i <= arrayLen(origCols); i++) {
    arrayAppend(desiredCols, origCols[i]);
    if (CompareNoCase(origCols[i], contactCol) == 0 and NOT inserted) {
        arrayAppend(desiredCols, "Directorate");
        inserted = true;
    }
}
/* If contactCol wasn't found, append Directorate to the end */
if (NOT inserted) {
    arrayAppend(desiredCols, "Directorate");
}

/* Create outQ with the new column order and pre-populate with empty arrays */
/* -------------------------
   Create outQ with sanitized column names (no spaces / invalid chars)
   and copy data into it. This avoids "invalid column name" errors.
   ------------------------- */

/* origCols and desiredCols should already be set earlier */
rowCount = dataQ.recordCount;

/* Build arrays: safeCols (actual query column names) and displayCols (original labels) */
safeCols = [];
displayCols = [];
safeNameSet = {}; // to ensure uniqueness

for (i = 1; i <= arrayLen(desiredCols); i++) {
    display = desiredCols[i];
    /* sanitize: replace non-alphanumeric chars with underscore */
    safe = reReplace(display, "[^A-Za-z0-9_]", "_", "all");
    /* collapse consecutive underscores */
    safe = reReplace(safe, "_{2,}", "_", "all");
    safe = trim(safe);
    /* ensure it starts with a letter - if not, prefix with C_ */
    if (len(safe) == 0) {
        safe = "C_" & i;
    } else if (NOT reFind("^[A-Za-z]", safe)) {
        safe = "C_" & safe;
    }
    /* ensure uniqueness: if already used, append suffix number */
    base = safe;
    suffix = 1;
    while (structKeyExists(safeNameSet, safe)) {
        safe = base & "_" & suffix;
        suffix++;
    }
    safeNameSet[safe] = true;

    arrayAppend(safeCols, safe);
    arrayAppend(displayCols, display);
}

/* Create outQ with the sanitized column names and blank arrays */
outQ = queryNew("");   // empty
for (i = 1; i <= arrayLen(safeCols); i++) {
    colName = safeCols[i];
    blankArr = arrayNew(1);
    for (j = 1; j <= rowCount; j++) {
        arrayAppend(blankArr, "");
    }
    QueryAddColumn(outQ, colName, blankArr);
}

/* Copy row values from dataQ into outQ, mapping original columns to safe names.
   If original dataQ had a column whose label differs (e.g. original had spaces),
   we use the original label to lookup values. */
for (r = 1; r <= rowCount; r++) {
    for (i = 1; i <= arrayLen(safeCols); i++) {
        sCol = safeCols[i];
        dCol = displayCols[i]; // the original display label we want to map from
        if (CompareNoCase(dCol, "Directorate") == 0) {
            val = dataQ.Directorate[r];
        } else {
            /* If dataQ has the column by exact name, copy it.
               But dataQ.columnList may use underscores etc. Try a few fallbacks:
               1) exact match
               2) underscore variant (spaces->underscores)
               3) case-insensitive match across columnList
            */
            val = "";
            if (listFindNoCase(dataQ.columnList, dCol)) {
                val = dataQ[dCol][r];
            } else {
                /* build underscore variant */
                alt = reReplace(dCol, "[^A-Za-z0-9_]", "_", "all");
                alt = reReplace(alt, "_{2,}", "_", "all");
                if (listFindNoCase(dataQ.columnList, alt)) {
                    val = dataQ[alt][r];
                } else {
                    /* try case-insensitive search across all columns */
                    found = false;
                    colsArr = listToArray(dataQ.columnList, ",");
                    for (ci = 1; ci <= arrayLen(colsArr); ci++) {
                        if (CompareNoCase(colsArr[ci], dCol) == 0) {
                            val = dataQ[ colsArr[ci] ][r];
                            found = true;
                            break;
                        }
                    }
                    if (NOT found) {
                        /* final fallback: leave blank */
                        val = "";
                    }
                }
            }
        }
        QuerySetCell(outQ, sCol, val, r);
    }
}

/* Replace dataQ with outQ for subsequent write operation */
dataQ = outQ;

/* Note: dataQ.columnList now contains the sanitized column names (safeCols). 
   The Excel output will therefore have headers like CLIENT_BRANCH instead of "CLIENT BRANCH".
   If you prefer to preserve the exact original header labels (with spaces),
   I can update the script to write the file manually and set the first row to displayCols. */

/* --- Now write dataQ (which is ordered as requested) to Excel with the safe write block --- */

// (Use the same safe write block we used before — with fallbacks & diagnostics)
// Example: write using preferred sheetname, fallback to sheet=1, fallback to default
outDir = "";
if (ReFind("[\\/]", outFile)) {
    lastSlashPos = ReFind("[\\/](?!.*[\\/])", outFile);
    if (lastSlashPos GT 1) {
        outDir = Left(outFile, lastSlashPos - 1);
    }
} else {
    outDir = "";
}
if (len(outDir) && NOT directoryExists(outDir)) {
    writeOutput("Error: output directory does not exist: " & outDir & "<br>");
    abort;
}

try {
    cfspreadsheet(action="write", filename=outFile, query="dataQ", sheetname=sheetName, overwrite=true);
    writeOutput("Write succeeded using sheetname('" & sheetName & "'). Output: " & outFile);
} catch (any e1) {
    try {
        cfspreadsheet(action="write", filename=outFile, query="dataQ", sheet=1, overwrite=true);
        writeOutput("Write succeeded using sheet=1 (first sheet). Output: " & outFile);
    } catch (any e2) {
        try {
            cfspreadsheet(action="write", filename=outFile, query="dataQ", overwrite=true);
            writeOutput("Write succeeded using default sheet (no sheet arg). Output: " & outFile);
        } catch (any e3) {
            writeOutput("<b>Failed to write spreadsheet. Tried these three methods. Errors below:</b><br><br>");
            writeOutput("<b>Attempt 1 (sheetname):</b><br>" & xmlFormat(e1.message) & "<br><br>");
            writeOutput("<b>Attempt 2 (sheet=1):</b><br>" & xmlFormat(e2.message) & "<br><br>");
            writeOutput("<b>Attempt 3 (no sheet):</b><br>" & xmlFormat(e3.message) & "<br><br>");
            writeOutput("<b>Diagnostics:</b><br>");
            writeOutput("outFile: " & outFile & "<br>");
            writeOutput("outDir: " & outDir & "<br>");
            writeOutput("dataQ.recordCount: " & (isQuery(dataQ) ? dataQ.recordCount : "no query") & "<br>");
            if (len(outDir) && directoryExists(outDir)) {
                writeOutput("Note: output directory exists. Please ensure ColdFusion/IIS user has write permission to that folder.<br>");
            } else {
                writeOutput("Note: output directory does not exist or couldn't be detected. Create it or correct outFile path.<br>");
            }
            abort;
        }
    }
}


/* Done */
writeOutput("Completed. Output saved to: " & outFile);
</cfscript>
